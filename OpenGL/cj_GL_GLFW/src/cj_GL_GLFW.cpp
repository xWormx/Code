#include "..\glad\glad.c"
#include "..\GLFW\glfw3.h"

void processInput(GLFWwindow *window);
void setViewportToWindowSize(GLFWwindow *window);

char *vertexshaderSrc = 
{
	"#version 330 core\n"
	"layout (location = 0) in vec3 aPos;\n"
	"void main()\n"
	"{\n"
	"gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
	"}\n"
};

char *fragmentshaderSrc = 
{
	"#version 330 core\n"
	"out vec4 FragColor;\n"
	"void main()\n"
	"{\n"
	"FragColor = vec4(1.0f, 0.0f, 0.0f, 1.0);\n"
	"}\n"
};

int main()
{
	glfwInit();
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

	GLFWwindow *window = glfwCreateWindow(800, 600, "cj_GL_GLFW", 0, 0);

	if(!window)
	{
		MessageBox(0, "window fail", 0, 0);
	}


	glfwMakeContextCurrent(window);

	glfwSwapInterval(1);

	if(!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
	{
		MessageBox(0, "GLAD loader fail", 0, 0);
	}
	
	// TODO: Kom ihåg att sätta viewport vid skärmens storleksändring


	printf("OpenGL %d.%d\n", GLVersion.major, GLVersion.minor);


	// Create a shader object and store it as an ID generated by 
	// glCreateShader();
	unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);

	// Attach the shader source code to the shader object and compile the shader
	glShaderSource(vertexShader, 1, &vertexshaderSrc, 0);
	glCompileShader(vertexShader);


	// Checking for shader compilation errors
	int success;
	char infoLog[512];
	glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
	if(!success)
	{
		glGetShaderInfoLog(vertexShader, 512, 0, infoLog);
		printf("ERROR-SHADER-VERTEX-COMPILATION_FAILED\n%s", infoLog);
	}

	// Create a fragment shader object and store it as an ID genereated be
	// glCreateShader();
	unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);

	// Attach the fragment shader src to the shader object and compile the shader
	glShaderSource(fragmentShader, 1, &fragmentshaderSrc, 0);
	glCompileShader(fragmentShader);

	glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
	if(!success)
	{
		glGetShaderInfoLog(fragmentShader, 512, 0, infoLog);
		printf("ERROR-SHADER-FRAGMENT-COMPILATION_FAILED\n%s", infoLog);
	}


	// Create a shader program object which is the final linked verions of multiple shaders combined
	unsigned int shaderProgram = glCreateProgram();

	// Attach the shaders to the program and link them
	glAttachShader(shaderProgram, vertexShader);
	glAttachShader(shaderProgram, fragmentShader);
	glLinkProgram(shaderProgram);

	// Check for linking errors
	glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
	if(!success)
	{
		glGetShaderInfoLog(shaderProgram, 512, 0, infoLog);
		printf("ERROR-SHADER-PROGRAM-LINK_FAILED\n%s", infoLog);
	}

	// Delete the shaders objects after they're linked togheter
	glDeleteShader(vertexShader);
	glDeleteShader(fragmentShader);


	float vertices[] =
	{
		 0.5f,  0.5f, 0.0f,
		 0.5f, -0.5f, 0.0f,
		-0.5f, -0.5f, 0.0f,
		-0.5f,  0.5f, 0.0f 
	};

	unsigned int indices[]=
	{
		0, 1, 3,
		1, 2, 3
	};

	/* Vertex buffer object, has unique ID corresponding to the buffer
	   glGenBuffer(GLsizei n, GLuint *buffers);
	   Returns n buffer object names in buffers */

	unsigned int VBO, VAO, EBO;
	glGenVertexArrays(1, &VAO);
	glGenBuffers(1, &VBO);
	glGenBuffers(1, &EBO);

	/* !!IMPORTANT!! to bind the vertex array object first, then bind and set vBuffers
	   and configure attributes */
	glBindVertexArray(VAO);

	/* Bind the buffer object to GL_ARRAY_BUFFER target
	   glBindBuffer(GLenum target, GLuint buffer); */
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);

	// Copy the vertex data into the buffer's memory
	glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

	// Set vertex attributes pointers
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
	glEnableVertexAttribArray(0);

	glBindBuffer(GL_ARRAY_BUFFER, 0);

	while(!glfwWindowShouldClose(window))
	{
		setViewportToWindowSize(window);
		processInput(window);
		
		glClearColor(1.0f, 0.5f, 0.0f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT);
	
		// Use the resulting shader program which every shader and rendering call will use
		glUseProgram(shaderProgram);
		glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

		glfwSwapBuffers(window);
		glfwPollEvents();


	}

	glDeleteVertexArrays(1, &VAO);
	glDeleteBuffers(1, &VBO);

	glfwTerminate();
	return 0;
}

void processInput(GLFWwindow *window)
{
	if(glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS)
	{
		printf("left arrow pressed\n");
		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	} 
	else 
	{	
		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	}	
}

void setViewportToWindowSize(GLFWwindow* window)
{
	int width = 0;
	int height = 0;
	glfwGetWindowSize(window, &width, &height);

	glViewport(0, 0, width, height);
}
